<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Way Slab Design | RC Design Suite</title>
    
    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    
    <!-- MathJax for Latex -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Three.js for 3D Visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        .visualization-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #f8fafc;
            max-width: 100%;
        }

        .summary-header {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #f1f5f9;
            color: var(--text-dark);
        }

        .result-item {
            margin-bottom: 1rem;
            font-size: 0.95rem;
            line-height: 1.6;
            color: #334155;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 700;
            margin-left: 8px;
        }
        .status-box { padding: 12px; border-radius: 8px; display: flex; align-items: flex-start; gap: 10px; font-weight: 600; margin-bottom: 10px; border: 1px solid transparent; }
        .status-success { background-color: #dcfce7; color: #166534; border-color: #bbf7d0; }
        .status-danger { background-color: #fee2e2; color: #991b1b; border-color: #fecaca; }
        .status-warning { background-color: #fef3c7; color: #92400e; border-color: #fde68a; }

        /* 3D Modal Styles */
        #modal3d { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:1000; flex-direction:column; align-items:center; justify-content:center; }
        .modal-content { width:90%; height:85%; background:white; border-radius:12px; position:relative; overflow:hidden; display: flex; flex-direction: column; }
        #threeContainer { flex: 1; width: 100%; background: #f0f2f5; }

        .latex-row {
            overflow-x: auto;
            padding: 0.5rem 0;
        }
    </style>
</head>
<body>

    <!-- 3D Modal -->
    <div id="modal3d">
        <div class="modal-content">
            <div style="padding: 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin:0;">3D Reinforcement Model</h3>
                <button onclick="close3DModal()" style="padding:8px 16px; background:var(--error); color:white; border:none; border-radius:6px; cursor:pointer; font-weight:600;">Close View</button>
            </div>
            <div id="threeContainer"></div>
            <div style="padding: 10px; background: #1e293b; color: white; font-size: 0.8rem; text-align: center;">
                <i class="fa-solid fa-mouse"></i> Left Click: Rotate | Scroll: Zoom | Right Click: Pan
            </div>
        </div>
    </div>
    
    <!-- SIDEBAR -->
    <nav class="sidebar">
        <a href="index.html" class="back-btn">
            <i class="fa-solid fa-arrow-left"></i> Dashboard
        </a>

        <div class="input-panel">
            <h2 class="panel-title">Slab Properties</h2>
            
            <div class="section-header">Slab Boundary & Continuity</div>
            <div class="input-group">
                <label>Panel Location</label>
                <select id="spanType">
                    <option value="continuous">Continuous (Interior Panel)</option>
                    <option value="simple">End Span (Exterior Panel)</option>
                </select>
            </div>
            <div class="input-group">
                <label>Discontinuous Edge Detail</label>
                <select id="edgeCondition">
                    <option value="1">Exterior edge unrestrained</option>
                    <option value="2">Slab with beams between all supports</option>
                    <option value="3" selected>Slab without beams (no edge beam)</option>
                    <option value="4">Slab without beams (with edge beam)</option>
                    <option value="5">Exterior edge fully restrained</option>
                </select>
            </div>
            <div class="form-row">
                <div class="form-col">
                    <label>$L_1$ Span (mm)</label>
                    <input type="number" id="l1" value="6000" step="100">
                </div>
                <div class="form-col">
                    <label>$L_2$ Span (mm)</label>
                    <input type="number" id="l2" value="5000" step="100">
                </div>
            </div>
            <div class="form-row">
                <div class="form-col">
                    <label>Column (mm)</label>
                    <input type="number" id="colSize" value="400" step="50">
                </div>
                <div class="form-col">
                    <label>Thickness $h$</label>
                    <input type="number" id="thickness" value="180" step="10">
                </div>
                <div class="form-col">
                    <label>Col Height (mm)</label>
                    <input type="number" id="colHeight" value="3000" step="100">
                </div>
            </div>

            <div class="section-header">Beam Geometry (Optional)</div>
            <div class="form-row">
                <div class="form-col">
                    <label>Beam Width $b_w$ (mm)</label>
                    <input type="number" id="beamBw" value="0" step="10">
                </div>
                <div class="form-col">
                    <label>Beam Depth $h_b$ (mm)</label>
                    <input type="number" id="beamH" value="0" step="10">
                </div>
            </div>

            <div class="section-header">Material Properties</div>
            <div class="form-row">
                <div class="form-col">
                    <label>Concrete $f'_c$</label>
                    <input type="number" id="fc" value="28" step="1">
                </div>
                <div class="form-col">
                    <label>Steel $f_y$</label>
                    <input type="number" id="fy" value="420" step="10">
                </div>
            </div>

            <div class="section-header">Applied Loads</div>
            <div class="form-row">
                <div class="form-col">
                    <label>SDL (kN/m²)</label>
                    <input type="number" id="wd" value="1.5" step="0.1">
                </div>
                <div class="form-col">
                    <label>Live (kN/m²)</label>
                    <input type="number" id="wl" value="2.4" step="0.1">
                </div>
            </div>

            <div class="section-header">Reinforcement</div>
            <div class="form-row">
                <div class="form-col">
                    <label>Bar Size (mm)</label>
                    <select id="barSize">
                        <option value="10">10 mm</option>
                        <option value="12" selected>12 mm</option>
                        <option value="16">16 mm</option>
                        <option value="20">20 mm</option>
                    </select>
                </div>
                <div class="form-col">
                    <label>Cover (mm)</label>
                    <input type="number" id="cover" value="20" step="5">
                </div>
            </div>

            <div class="section-header">Visualization</div>
            <div class="input-group">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.85rem; background: #f8fafc; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color);">
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="showL1" checked style="width: auto;"> L1 Bars
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="showL2" checked style="width: auto;"> L2 Bars
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="showPos" checked style="width: auto;"> Positive
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; margin: 0; cursor: pointer;">
                        <input type="checkbox" id="showNeg" checked style="width: auto;"> Negative
                    </label>
                </div>
            </div>

            <button class="btn-calc" onclick="calculateDesign()">Calculate & Render</button>
        </div>
    </nav>

        <!-- Results Panel -->
        <main class="results-panel">
            <!-- Hero Section -->
            <div class="hero">
                <h1>Two-Way Slab Design</h1>
                <p>Design reinforced concrete slabs with two-way action using the Direct Design Method (DDM) based on ACI 318M-11.</p>
            </div>

            
            <!-- Visualization -->
            <div class="visualization-card">
                <h4 style="margin-bottom: 1rem; width:100%; border-bottom:1px solid #e2e8f0; padding-bottom:0.5rem; display: flex; justify-content: space-between; align-items: center;">
                    Slab Detailing Visualization (Plan View)
                    <button onclick="open3DModal()" style="padding: 6px 12px; background: var(--sidebar-bg); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 6px;">
                        <i class="fa-solid fa-cube"></i> View 3D Model
                    </button>
                </h4>
                <canvas id="slabCanvas" width="700" height="500"></canvas>
                <p style="font-size: 0.8rem; color: #64748b; margin-top: 0.5rem;">*Visualization represents reinforcement in the direction of analysis ($L_1$)</p>
            </div>

            <!-- Summary -->
            <div class="card">
                <div class="summary-header">Design Calculations & Checks</div>
                <div id="output">
                    <p style="color: #64748b; font-style: italic;">Adjust inputs and click "Calculate" to generate results.</p>
                </div>
            </div>

        </main>

    <script>
        // Constants
        const CONCRETE_DENSITY = 24; // kN/m^3
        const E_STEEL = 200000; // MPa
        let lastDesignData = null;

        function calculateDesign() {
            // 1. Get Inputs
            const spanType = document.getElementById('spanType').value;
            const edgeCond = parseInt(document.getElementById('edgeCondition').value);
            const l1 = parseFloat(document.getElementById('l1').value); // Long Span
            const l2 = parseFloat(document.getElementById('l2').value); // Short Span
            const col = parseFloat(document.getElementById('colSize').value);
            const h = parseFloat(document.getElementById('thickness').value);
            const colHeight = parseFloat(document.getElementById('colHeight').value);
            const fc = parseFloat(document.getElementById('fc').value);
            const fy = parseFloat(document.getElementById('fy').value);
            const w_sdl = parseFloat(document.getElementById('wd').value);
            const w_l = parseFloat(document.getElementById('wl').value);
            const db = parseFloat(document.getElementById('barSize').value);
            const cover = parseFloat(document.getElementById('cover').value);
            const beamBw = parseFloat(document.getElementById('beamBw').value) || 0;
            const beamH = parseFloat(document.getElementById('beamH').value) || 0;

            // Validation to prevent numerical instability
            if (isNaN(fc) || fc < 12 || isNaN(fy) || fy < 200) {
                document.getElementById('output').innerHTML = "<p style='color: var(--error); font-weight: 600; padding: 1rem;'>Please enter valid material properties ($f'_c \\ge 12$ MPa and $f_y \\ge 200$ MPa).</p>";
                return;
            }

            // 2. Loads
            const w_self = (h / 1000) * CONCRETE_DENSITY; // kN/m^2
            const w_d_total = w_sdl + w_self;
            const w_u = 1.2 * w_d_total + 1.6 * w_l; // Factored Load kN/m^2
            const phi = 0.9;
            const d = h - cover - db; 
            const Ec = 4700 * Math.sqrt(fc);

            // 3. DDM Limitations Check (ACI 13.6.1)
            const l_ratio_check = Math.max(l1, l2) / Math.min(l1, l2);
            const load_ratio_check = w_l / w_d_total;
            const isDDMValid = l_ratio_check <= 2.0 && load_ratio_check <= 2.0;
            let stiffness_details = { l1: null, l2: null };

            // 4. Analysis Helper (DDM or EFM)
            function analyzeDirection(span_l1, span_l2, alpha_f, dirKey) {
                const ln = span_l1 - col;
                const ln_m = ln / 1000;
                const l2_m = span_l2 / 1000;
                const Mo = (w_u * l2_m * Math.pow(ln_m, 2)) / 8;
                let method_used = "DDM";
                // Table 16.2 Distribution
                let neg_factor = 0.65, pos_factor = 0.35, ext_neg_factor = 0;
                if (spanType === 'simple') {
                    const factors = {
                        1: [0.75, 0.63, 0],
                        2: [0.70, 0.57, 0.16],
                        3: [0.70, 0.52, 0.26],
                        4: [0.70, 0.50, 0.30],
                        5: [0.65, 0.35, 0.65]
                    };
                    [neg_factor, pos_factor, ext_neg_factor] = factors[edgeCond];

                    // EFM Logic if DDM is invalid (Chapter 17)
                    if (!isDDMValid) {
                        method_used = "EFM";
                        const Is = (span_l2 * Math.pow(h, 3)) / 12;
                        const Ic = (Math.pow(col, 4)) / 12;
                        const Ks = 4 * Ec * Is / span_l1;
                        const Kc = 4 * Ec * Ic / colHeight;
                        const C = (1 - 0.63 * h / col) * (Math.pow(h, 3) * col / 3);
                        const Kt = (9 * Ec * C) / (span_l2 * Math.pow(1 - col/span_l2, 3));
                        const Kec = (2 * Kc * 2 * Kt) / (2 * Kc + 2 * Kt);
                        const alpha_ec = Kec / Ks;
                        ext_neg_factor = 0.65 * (alpha_ec / (1 + alpha_ec));
                        pos_factor = 0.63 - 0.28 * (alpha_ec / (1 + alpha_ec));
                        neg_factor = 0.75 - 0.10 * (alpha_ec / (1 + alpha_ec));
                        stiffness_details[dirKey] = { Ks, Kc, Kt, Kec, alpha_ec };
                    }
                }

                const M_neg = neg_factor * Mo;
                const M_pos = pos_factor * Mo;
                const M_ext_neg = ext_neg_factor * Mo;

                // CS Percentages (Equations from Chapter 16.8)
                const alpha_ratio = Math.min(alpha_f * span_l2 / span_l1, 1.0);
                const l_ratio = span_l2 / span_l1;
                
                const pct_int_neg = 75 + 30 * alpha_ratio * (1 - l_ratio);
                const pct_pos = 60 + 30 * alpha_ratio * (1.5 - l_ratio);
                // Simplified beta_t = 0 for flat plate, 2.5 for stiff edge beam
                const beta_t = (edgeCond === 2 || edgeCond === 4) ? 2.5 : 0;
                const pct_ext_neg = 100 - 10 * beta_t + 12 * alpha_ratio * (1 - l_ratio);

                return {
                    Mo, M_neg, M_pos, M_ext_neg,
                    cs_neg: pct_int_neg / 100,
                    cs_pos: pct_pos / 100,
                    cs_ext_neg: pct_ext_neg / 100,
                    ln,
                    method: method_used
                };
            }

            // Calculate alpha_f (Simplified)
            const alpha_f = (beamBw > 0) ? (beamBw * Math.pow(beamH, 3)) / (l2 * Math.pow(h, 3)) : 0;
            const res1 = analyzeDirection(l1, l2, alpha_f, 'l1');
            const res2 = analyzeDirection(l2, l1, alpha_f, 'l2');

            // 5. Reinforcement Calculation
            function getSpacing(M, width_mm, d_eff) {
                if (M <= 0) return { spacing: 450, area: 0 };
                let As = (M * 1e6) / (phi * fy * 0.9 * d_eff);
                const As_min = 0.0018 * width_mm * h;
                As = Math.max(As, As_min);
                const s = Math.min(450, 2 * h, (width_mm * (Math.PI * db**2 / 4)) / As);
                return { spacing: Math.floor(s), area: As };
            }

            const d1 = {
                cs_pos: getSpacing(res1.M_pos * res1.cs_pos, l2/2, d).spacing,
                ms_pos: getSpacing(res1.M_pos * (1 - res1.cs_pos), l2/2, d).spacing,
                cs_neg: getSpacing(res1.M_neg * res1.cs_neg, l2/2, d).spacing
            };
            const d2 = {
                cs_pos: getSpacing(res2.M_pos * res2.cs_pos, l1/2, d - db).spacing,
                ms_pos: getSpacing(res2.M_pos * (1 - res2.cs_pos), l1/2, d - db).spacing,
                cs_neg: getSpacing(res2.M_neg * res2.cs_neg, l1/2, d - db).spacing
            };

            // 6. Checks
            const ln_max = Math.max(l1, l2) - col;
            const h_min = (spanType === 'simple') ? ln_max / 20 : ln_max / 33;

            const Vu_1way = w_u * (res1.ln / 2000 - d / 1000);
            const phiVc_1way = 0.75 * 0.17 * Math.sqrt(fc) * 1000 * d / 1000;

            const bo = 4 * (col + d);
            const Vu_punch = w_u * (l1 * l2 / 1e6 - Math.pow(col + d, 2) / 1e6);
            const phiVc_punch = 0.75 * 0.33 * Math.sqrt(fc) * bo * d / 1000;

            // Deflection Check (Simplified Elastic)
            const Ig = (1000 * Math.pow(h, 3)) / 12;
            const w_service = w_d_total + w_l;
            const delta_elastic = (5 * w_service * Math.pow(res1.ln, 4)) / (384 * Ec * Ig);
            const delta_allow = res1.ln / 360;

            // 7. Render Output
            const out = document.getElementById('output');
            out.innerHTML = `
                <div class="result-block">
                    <div class="result-header"><i class="fa-solid fa-star"></i> Critical Design Results</div>
                    <div class="status-box ${isDDMValid ? 'status-success' : 'status-warning'}">
                        <i class="fa-solid ${isDDMValid ? 'fa-check-circle' : 'fa-triangle-exclamation'}"></i>
                        <div>Method: ${isDDMValid ? 'Direct Design Method (DDM)' : 'Equivalent Frame Method (EFM)'} ${!isDDMValid ? '<br><small style="font-weight:400;">DDM limits exceeded (L/S ratio or L/D ratio). Analysis performed using EFM stiffness factors.</small>' : ''}</div>
                    </div>
                    <div class="status-box ${h >= h_min ? 'status-success' : 'status-danger'}">
                        <i class="fa-solid ${h >= h_min ? 'fa-check-circle' : 'fa-circle-xmark'}"></i>
                        <div>Thickness: Provided ${h}mm (Min Req: ${h_min.toFixed(0)}mm)${h < h_min ? '<br><small style="font-weight:400;">Recommendation: Increase slab thickness to meet ACI minimum requirements for deflection control.</small>' : ''}</div>
                    </div>
                    <div class="status-box ${delta_elastic < delta_allow ? 'status-success' : 'status-warning'}">
                        <i class="fa-solid ${delta_elastic < delta_allow ? 'fa-check-circle' : 'fa-triangle-exclamation'}"></i>
                        <div>Deflection: $\Delta_{calc} = ${delta_elastic.toFixed(2)}mm$ (Limit $L/360 = ${delta_allow.toFixed(2)}mm$)${delta_elastic >= delta_allow ? '<br><small style="font-weight:400;">Recommendation: Increase slab thickness or concrete strength ($f\'_c$) to reduce elastic deflection.</small>' : ''}</div>
                    </div>
                    <div class="status-box ${Vu_punch < phiVc_punch ? 'status-success' : 'status-danger'}">
                        <i class="fa-solid ${Vu_punch < phiVc_punch ? 'fa-check-circle' : 'fa-circle-xmark'}"></i>
                        <div>Punching Shear: $V_u = ${Vu_punch.toFixed(1)}kN$ vs $\phi V_c = ${phiVc_punch.toFixed(1)}kN$${Vu_punch >= phiVc_punch ? '<br><small style="font-weight:400;">Recommendation: Increase slab thickness, column size, concrete strength, or use shear reinforcement (studs/shearheads).</small>' : ''}</div>
                    </div>
                    <div class="status-box ${Vu_1way < phiVc_1way ? 'status-success' : 'status-danger'}">
                        <i class="fa-solid ${Vu_1way < phiVc_1way ? 'fa-check-circle' : 'fa-circle-xmark'}"></i>
                        <div>One-Way Shear: $V_u = ${Vu_1way.toFixed(1)}kN/m$ vs $\phi V_c = ${phiVc_1way.toFixed(1)}kN/m$${Vu_1way >= phiVc_1way ? '<br><small style="font-weight:400;">Recommendation: Increase slab thickness or concrete strength ($f\'_c$).</small>' : ''}</div>
                    </div>
                </div>

                <div class="result-block">
                    <div class="result-header"><i class="fa-solid fa-calculator"></i> Detailed Analysis</div>
                    <div class="latex-row">
                        $$ w_u = 1.2(${w_d_total.toFixed(2)}) + 1.6(${w_l}) = ${w_u.toFixed(2)} \\text{ kN/m}^2 $$
                        $$ M_{o1} = \\frac{w_u l_2 l_{n1}^2}{8} = ${res1.Mo.toFixed(1)} \\text{ kNm} $$
                        $$ M_{o2} = \\frac{w_u l_1 l_{n2}^2}{8} = ${res2.Mo.toFixed(1)} \\text{ kNm} $$
                    </div>
                    ${!isDDMValid && stiffness_details.l1 ? `
                    <p><strong>EFM Stiffness Parameters ($L_1$):</strong></p>
                    <div class="latex-row">
                        $$ K_s = ${stiffness_details.l1.Ks.toExponential(2)}, \\quad K_{ec} = ${stiffness_details.l1.Kec.toExponential(2)} $$
                        $$ \\alpha_{ec} = \\frac{K_{ec}}{K_s} = ${stiffness_details.l1.alpha_ec.toFixed(2)} $$
                    </div>
                    ` : ''}
                    <p><strong>Reinforcement Summary:</strong></p>
                    <table style="width:100%; border-collapse:collapse; font-size:0.85rem;">
                        <tr style="background:#f8fafc; border-bottom:2px solid #eee;">
                            <th style="padding:8px; text-align:left;">Strip</th><th style="padding:8px;">Moment</th><th style="padding:8px;">Spacing</th>
                        </tr>
                        <tr><td style="padding:8px;">L1 Col Strip (-M)</td><td style="padding:8px; text-align:center;">${(res1.M_neg * res1.cs_neg).toFixed(1)} kNm</td><td style="padding:8px; text-align:center;">@ ${d1.cs_neg} mm</td></tr>
                        <tr><td style="padding:8px;">L1 Col Strip (+M)</td><td style="padding:8px; text-align:center;">${(res1.M_pos * res1.cs_pos).toFixed(1)} kNm</td><td style="padding:8px; text-align:center;">@ ${d1.cs_pos} mm</td></tr>
                        <tr><td style="padding:8px;">L1 Mid Strip (+M)</td><td style="padding:8px; text-align:center;">${(res1.M_pos * (1-res1.cs_pos)).toFixed(1)} kNm</td><td style="padding:8px; text-align:center;">@ ${d1.ms_pos} mm</td></tr>
                        <tr><td style="padding:8px;">L2 Col Strip (-M)</td><td style="padding:8px; text-align:center;">${(res2.M_neg * res2.cs_neg).toFixed(1)} kNm</td><td style="padding:8px; text-align:center;">@ ${d2.cs_neg} mm</td></tr>
                        <tr><td style="padding:8px;">L2 Col Strip (+M)</td><td style="padding:8px; text-align:center;">${(res2.M_pos * res2.cs_pos).toFixed(1)} kNm</td><td style="padding:8px; text-align:center;">@ ${d2.cs_pos} mm</td></tr>
                        <tr><td style="padding:8px;">L2 Mid Strip (+M)</td><td style="padding:8px; text-align:center;">${(res2.M_pos * (1-res2.cs_pos)).toFixed(1)} kNm</td><td style="padding:8px; text-align:center;">@ ${d2.ms_pos} mm</td></tr>
                    </table>
                </div>
            `;

            const filters = {
                showPos: document.getElementById('showPos').checked,
                showNeg: document.getElementById('showNeg').checked,
                showL1: document.getElementById('showL1').checked,
                showL2: document.getElementById('showL2').checked
            };

            lastDesignData = { l1, l2, col, h, fc, fy, db, cover, type: spanType, d1, d2, filters };

            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise();
            }

            drawSlab(l1, l2, col, spanType, d1, d2, filters, db);
        }

        function drawSlab(l1, l2, col, type, d1, d2, filters, db) {
            const canvas = document.getElementById('slabCanvas');
            const ctx = canvas.getContext('2d');
            
            // Reset
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 60;
            const drawWidth = canvas.width - (padding * 2);
            const drawHeight = canvas.height - (padding * 2);
            
            // Scale factors to fit slab in canvas
            // We want to draw a rectangle representing L1 x L2
            // L1 is usually horizontal in plan view context here
            const scaleX = drawWidth / l1;
            const scaleY = drawHeight / l2;
            const scale = Math.min(scaleX, scaleY);
            
            const rectW = l1 * scale;
            const rectH = l2 * scale;
            
            const startX = (canvas.width - rectW) / 2;
            const startY = (canvas.height - rectH) / 2;

            // 1. Draw Slab Outline
            ctx.strokeStyle = "#0f172a";
            ctx.lineWidth = 3;
            ctx.strokeRect(startX, startY, rectW, rectH);
            ctx.fillStyle = "#f8fafc";
            ctx.fillRect(startX, startY, rectW, rectH);

            // 2. Draw Columns
            const colW = col * scale;
            const colH = col * scale;
            ctx.fillStyle = "#cbd5e1";
            
            const colPositions = [
                [startX - colW/2, startY - colH/2],
                [startX + rectW - colW/2, startY - colH/2],
                [startX - colW/2, startY + rectH - colH/2],
                [startX + rectW - colW/2, startY + rectH - colH/2]
            ];

            colPositions.forEach(pos => {
                ctx.fillRect(pos[0], pos[1], colW, colH);
                ctx.strokeRect(pos[0], pos[1], colW, colH);
            });

            // 3. Draw Column Strips vs Middle Strips (Dashed Lines)
            const cs_width1 = (Math.min(l1, l2) / 4) * scale;
            const cs_width2 = (Math.min(l1, l2) / 4) * scale;
            
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 1;
            
            // Horizontal CS Boundaries
            ctx.beginPath(); ctx.moveTo(startX, startY + cs_width1); ctx.lineTo(startX + rectW, startY + cs_width1); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX, startY + rectH - cs_width1); ctx.lineTo(startX + rectW, startY + rectH - cs_width1); ctx.stroke();

            // Vertical CS Boundaries
            ctx.beginPath(); ctx.moveTo(startX + cs_width2, startY); ctx.lineTo(startX + cs_width2, startY + rectH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX + rectW - cs_width2, startY); ctx.lineTo(startX + rectW - cs_width2, startY + rectH); ctx.stroke();

            ctx.setLineDash([]);

            // 4. Draw Rebar Representations
            
            // L1 Direction (Horizontal)
            if (filters.showL1) {
                if (filters.showPos) {
                    drawBarsH(startY + cs_width1, startY + rectH - cs_width1, d1.ms_pos, "#3b82f6", `L1 MS Pos: Ø${db}@${d1.ms_pos}`);
                    drawBarsH(startY, startY + cs_width1, d1.cs_pos, "#10b981", `L1 CS Pos: Ø${db}@${d1.cs_pos}`);
                    drawBarsH(startY + rectH - cs_width1, startY + rectH, d1.cs_pos, "#10b981", "");
                }
                if (filters.showNeg && type === 'continuous') {
                    drawNegBarsH(startY, startY + cs_width1, d1.cs_neg, "#ef4444", `L1 CS Neg: Ø${db}@${d1.cs_neg}`);
                    drawNegBarsH(startY + rectH - cs_width1, startY + rectH, d1.cs_neg, "#ef4444", "");
                }
            }

            // L2 Direction (Vertical)
            if (filters.showL2) {
                if (filters.showPos) {
                    drawBarsV(startX + cs_width2, startX + rectW - cs_width2, d2.ms_pos, "#3b82f6", `L2 MS Pos: Ø${db}@${d2.ms_pos}`);
                    drawBarsV(startX, startX + cs_width2, d2.cs_pos, "#10b981", `L2 CS Pos: Ø${db}@${d2.cs_pos}`);
                    drawBarsV(startX + rectW - cs_width2, startX + rectW, d2.cs_pos, "#10b981", "");
                }
                if (filters.showNeg && type === 'continuous') {
                    drawNegBarsV(startX, startX + cs_width2, d2.cs_neg, "#ef4444", `L2 CS Neg: Ø${db}@${d2.cs_neg}`);
                    drawNegBarsV(startX + rectW - cs_width2, startX + rectW, d2.cs_neg, "#ef4444", "");
                }
            }

            function drawBarsH(yStart, yEnd, spacing_mm, color, label) {
                const stripH = yEnd - yStart;
                const spacing_px = spacing_mm * scale;
                let drawSpacing = Math.max(spacing_px, 8); 
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                for(let y = yStart + drawSpacing/2; y < yEnd; y += drawSpacing) {
                    ctx.beginPath(); ctx.moveTo(startX + 10, y); ctx.lineTo(startX + rectW - 10, y); ctx.stroke();
                }
                if (label) {
                    ctx.fillStyle = "#0f172a"; ctx.font = "11px Inter"; ctx.textAlign = "center";
                    ctx.fillText(label, startX + rectW/2, yStart + stripH/2 + 4);
                }
            }

            function drawBarsV(xStart, xEnd, spacing_mm, color, label) {
                const stripW = xEnd - xStart;
                const spacing_px = spacing_mm * scale;
                let drawSpacing = Math.max(spacing_px, 8);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                for(let x = xStart + drawSpacing/2; x < xEnd; x += drawSpacing) {
                    ctx.beginPath(); ctx.moveTo(x, startY + 10); ctx.lineTo(x, startY + rectH - 10); ctx.stroke();
                }
                if (label) {
                    ctx.save();
                    ctx.translate(xStart + stripW/2, startY + rectH/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillStyle = "#0f172a"; ctx.font = "11px Inter"; ctx.textAlign = "center";
                    ctx.fillText(label, 0, 0);
                    ctx.restore();
                }
            }

            function drawNegBarsH(yStart, yEnd, spacing_mm, color, label) {
                if (spacing_mm <= 0) return;
                const stripH = yEnd - yStart;
                const spacing_px = spacing_mm * scale;
                let drawSpacing = Math.max(spacing_px, 8);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                const barLen = 0.3 * l1 * scale;
                for(let y = yStart + drawSpacing/2; y < yEnd; y += drawSpacing) {
                    ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX + barLen, y); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(startX + rectW, y); ctx.lineTo(startX + rectW - barLen, y); ctx.stroke();
                }
                if (label) {
                    ctx.fillStyle = color; ctx.font = "bold 11px Inter"; ctx.textAlign = "center";
                    ctx.fillText(label, startX + barLen/2, yStart + stripH/2 + 4);
                }
            }

            function drawNegBarsV(xStart, xEnd, spacing_mm, color, label) {
                if (spacing_mm <= 0) return;
                const stripW = xEnd - xStart;
                const spacing_px = spacing_mm * scale;
                let drawSpacing = Math.max(spacing_px, 8);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                const barLen = 0.3 * l2 * scale;
                for(let x = xStart + drawSpacing/2; x < xEnd; x += drawSpacing) {
                    ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY + barLen); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(x, startY + rectH); ctx.lineTo(x, startY + rectH - barLen); ctx.stroke();
                }
                if (label) {
                    ctx.save();
                    ctx.translate(xStart + stripW/2, startY + barLen/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillStyle = color; ctx.font = "bold 11px Inter"; ctx.textAlign = "center";
                    ctx.fillText(label, 0, 0);
                    ctx.restore();
                }
            }

            // 5. Annotations (L1, L2)
            ctx.fillStyle = "#0f172a"; ctx.font = "bold 14px Inter"; ctx.textAlign = "center";
            ctx.fillText(`L1 = ${l1} mm`, startX + rectW/2, startY - 25);
            ctx.save(); ctx.translate(startX - 35, startY + rectH/2); ctx.rotate(-Math.PI/2);
            ctx.fillText(`L2 = ${l2} mm`, 0, 0); ctx.restore();
        }

        // --- 3D VISUALIZATION LOGIC ---
        let scene, camera, renderer, controls;

        function open3DModal() {
            if (!lastDesignData) return;
            document.getElementById('modal3d').style.display = 'flex';
            init3DScene();
        }

        function close3DModal() {
            document.getElementById('modal3d').style.display = 'none';
            if (renderer) {
                renderer.dispose();
                const container = document.getElementById('threeContainer');
                if (container.firstChild) container.removeChild(renderer.domElement);
            }
        }

        function init3DScene() {
            const container = document.getElementById('threeContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);

            camera = new THREE.PerspectiveCamera(45, width / height, 10, 50000);
            camera.position.set(lastDesignData.l1 * 0.8, lastDesignData.l1 * 0.6, lastDesignData.l2 * 0.8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(1, 1, 1);
            scene.add(sun);

            const data = lastDesignData;
            const { l1, l2, h, col, cover, db, filters, d1, d2, type } = data;

            // Slab (Transparent)
            const slab = new THREE.Mesh(
                new THREE.BoxGeometry(l1, h, l2),
                new THREE.MeshPhongMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.3 })
            );
            scene.add(slab);

            // Columns
            const colGeom = new THREE.BoxGeometry(col, 1000, col);
            const colMat = new THREE.MeshPhongMaterial({ color: 0x475569 });
            [ [1,1], [-1,1], [1,-1], [-1,-1] ].forEach(s => {
                const c = new THREE.Mesh(colGeom, colMat);
                c.position.set(s[0]*(l1/2 - col/2), -500 - h/2, s[1]*(l2/2 - col/2));
                scene.add(c);
            });

            const barMatPos = new THREE.MeshPhongMaterial({ color: 0x3b82f6 });
            const barMatNeg = new THREE.MeshPhongMaterial({ color: 0xef4444 });
            const cs_w1 = Math.min(l1, l2) / 4;
            const cs_w2 = Math.min(l1, l2) / 4;

            // L1 Bars (X-axis)
            if (filters.showL1) {
                if (filters.showPos) {
                    addBars3D(l1-40, db, d1.ms_pos, -l2/2 + cs_w1, l2/2 - cs_w1, -h/2 + cover + db/2, 'x', barMatPos);
                    addBars3D(l1-40, db, d1.cs_pos, -l2/2, -l2/2 + cs_w1, -h/2 + cover + db/2, 'x', barMatPos);
                    addBars3D(l1-40, db, d1.cs_pos, l2/2 - cs_w1, l2/2, -h/2 + cover + db/2, 'x', barMatPos);
                }
                if (filters.showNeg && type === 'continuous') {
                    const len = 0.3 * l1;
                    [[-1, -l2/2, -l2/2+cs_w1], [1, -l2/2, -l2/2+cs_w1], [-1, l2/2-cs_w1, l2/2], [1, l2/2-cs_w1, l2/2]].forEach(p => {
                        addBars3D(len, db, d1.cs_neg, p[1], p[2], h/2 - cover - db/2, 'x', barMatNeg, p[0]*(l1/2 - len/2));
                    });
                }
            }
            // L2 Bars (Z-axis)
            if (filters.showL2) {
                if (filters.showPos) {
                    addBars3D(l2-40, db, d2.ms_pos, -l1/2 + cs_w2, l1/2 - cs_w2, -h/2 + cover + db + db/2, 'z', barMatPos);
                    addBars3D(l2-40, db, d2.cs_pos, -l1/2, -l1/2 + cs_w2, -h/2 + cover + db + db/2, 'z', barMatPos);
                    addBars3D(l2-40, db, d2.cs_pos, l1/2 - cs_w2, l1/2, -h/2 + cover + db + db/2, 'z', barMatPos);
                }
                if (filters.showNeg && type === 'continuous') {
                    const len = 0.3 * l2;
                    [[-1, -l1/2, -l1/2+cs_w2], [1, -l1/2, -l1/2+cs_w2], [-1, l1/2-cs_w2, l1/2], [1, l1/2-cs_w2, l1/2]].forEach(p => {
                        addBars3D(len, db, d2.cs_neg, p[1], p[2], h/2 - cover - db - db/2, 'z', barMatNeg, p[0]*(l2/2 - len/2));
                    });
                }
            }
            animate();
        }

        function addBars3D(len, dia, space, start, end, y, axis, mat, fixed = 0) {
            if (space <= 0) return;
            const geom = new THREE.CylinderGeometry(dia/2, dia/2, len, 8);
            if (axis === 'x') geom.rotateZ(Math.PI/2); else geom.rotateX(Math.PI/2);
            for (let p = start + space/2; p < end; p += space) {
                const m = new THREE.Mesh(geom, mat);
                if (axis === 'x') m.position.set(fixed, y, p); else m.position.set(p, y, fixed);
                scene.add(m);
            }
        }

        function animate() {
            if (document.getElementById('modal3d').style.display === 'none') return;
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Initial Draw on Load
        window.onload = function() {
            if (window.MathJax && MathJax.typeset) {
                MathJax.typeset();
            }
            // Attach listeners to all inputs for live update
            document.querySelectorAll('.input-panel input, .input-panel select').forEach(el => {
                el.addEventListener('input', calculateDesign);
            });
            calculateDesign();
        };

    </script>
</body>
</html>